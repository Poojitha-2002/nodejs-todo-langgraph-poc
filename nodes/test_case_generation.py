import os
import re
import subprocess
from typing import Any
from dotenv import load_dotenv
from langchain_core.prompts import ChatPromptTemplate
from langchain_google_genai import ChatGoogleGenerativeAI
from schemas.state_schemas import AppState
import importlib.util
import sys

load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")


def load_login_function_from_path(path: str):
    module_name = "dynamic_login_module"
    spec = importlib.util.spec_from_file_location(module_name, path)
    module = importlib.util.module_from_spec(spec)
    sys.modules[module_name] = module
    spec.loader.exec_module(module)
    return module.login


def extract_code_blocks(text: str) -> str:
    code_match = re.search(r"```(?:python)?\s*(.*?)```", text, re.DOTALL)
    return code_match.group(1).strip() if code_match else text.strip()


def generate_test_case(state: AppState) -> dict:
    selenium_code_path = state["selenium_code_path"]
    login_url = state["login_url"]
    email = state["email"]
    password = state["password"]
    home_page_url = state["home_page_url"]

    if selenium_code_path and os.path.exists(selenium_code_path):
        with open(selenium_code_path, "r", encoding="utf-8") as f:
            selenium_code = f.read()
    else:
        selenium_code = state.get("selenium_code", "")

    if not selenium_code:
        return {"error": "Missing selenium_code or valid selenium_code_path in state."}
    if not login_url:
        return {"error": "Missing login_url in state."}
    if not home_page_url:
        return {"error": "Missing home_page_url in state."}

    prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                "You are a helpful Python test engineer. Return only executable Python unittest code.",
            ),
            (
                "human",
                """Given a Selenium login function, generate a Python `unittest` file `test_case.py`. The `login` function should:
                - Take `url`, `username`, `password`, and `home_page_url_segment` as arguments.
                - Initialize and manage the WebDriver (e.g., Chrome).
                - Navigate to the login URL.
                - Locate and interact with the email, password, and login button elements.
                - After clicking the login button, **wait for redirection to a successful home page (e.g., containing '{home_page_url}')**.
                - **Return the WebDriver instance ONLY if the login is successful** (i.e., redirected to the home page).
                - **Return `False` if the login fails** (e.g., due to invalid credentials, missing fields, timeout, or elements not found on the login page after submission).
                - **Ensure the WebDriver is quit within the `login` function itself if the login fails** (i.e., if `False` is returned).

                The generated `test_case.py` must:
                - Reuse the exact email '{email}' and password '{password}' values.
                - Import necessary modules (`unittest`, `selenium.webdriver`, `selenium.webdriver.common.by`, `selenium.webdriver.support.ui`, `selenium.webdriver.support.expected_conditions`).
                - Define a `TestLogin` class inheriting from `unittest.TestCase`.
                - Generate various test cases.
                - Validate test cases generated by validating whether the redirection is happening to {home_page_url}.
                - Define all required classes and methods cleanly.

                ### Login URL:
                {login_url}

                ### Expected Home Page URL Segment (for successful login verification):
                {home_page_url}

                ### Provided Selenium Function (adapt this or use its structure):
                {selenium_code}
            """,
            ),
        ]
    )

    formatted_messages = prompt.format_messages(
        login_url=login_url,
        selenium_code=selenium_code,
        email=email,
        password=password,
        home_page_url=home_page_url,
    )

    try:
        llm = ChatGoogleGenerativeAI(
            model="gemini-1.5-flash-latest", google_api_key=api_key, temperature=0
        )
        response = llm.invoke(formatted_messages)
        test_code_raw = response.content
        parsed_code = extract_code_blocks(test_code_raw)

        output_dir = "generated_code"
        os.makedirs(output_dir, exist_ok=True)
        test_file_path = os.path.join(output_dir, "test_case.py")

        with open(test_file_path, "w", encoding="utf-8") as f:
            f.write(parsed_code)

        print(f"Test case generated and saved to '{test_file_path}'.")
        return {
            "test_file_path": test_file_path,
            "test_code": parsed_code,
        }
    except Exception as e:
        print(f"Error generating test case: {e}")
        return {"error": str(e)}


def run_tests_and_get_output(test_file_path: str) -> str:
    command = ["python", "-m", "unittest", test_file_path]
    result = subprocess.run(
        command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
    )
    return result.stdout


def generate_test_report_from_output(raw_output: str) -> str:
    prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                "You are a Python QA engineer. Create a clean, readable test report based on the raw output from Python's unittest.",
            ),
            (
                "human",
                """Here is the raw unittest output:\n\n{raw_output}\n\n
                Generate a test report in markdown format with:
                - Summary section (total, passed, failed)
                - Bullet points for each test with result
                - Clear formatting""",
            ),
        ]
    )

    messages = prompt.format_messages(raw_output=raw_output)
    try:
        llm = ChatGoogleGenerativeAI(
            model="gemini-1.5-flash-latest", google_api_key=api_key, temperature=0.2
        )
        response = llm.invoke(messages)
        return response.content
    except Exception as e:
        print(f":x: Failed to generate test report: {e}")
        return f"Error: {e}"


def save_test_report(report: str, path: str = "generated_code/test_report.md"):
    with open(path, "a", encoding="utf-8") as f:
        f.write(report)
    print(f": Test report saved to {path}")


def generate_test_case_with_report(
    state: AppState,
) -> dict[str, bool | str | None | Any] | AppState:
    result = generate_test_case(state)
    if "error" in result:
        return {
            "test_file_path": None,
            "test_code": None,
            "report_generated": False,
            "status": "fail",
            "error": result["error"],
        }
    state["error"] = None

    test_file_path = result["test_file_path"]
    parsed_code = result["test_code"]

    login_url = state.get("login_url")
    username = state.get("email")
    password = state.get("password")
    home_page_url = state.get("home_page_url")

    try:

        selenium_code_path = state["selenium_code_path"]
        login = load_login_function_from_path(selenium_code_path)
        prevalidate_result = login(login_url, username, password, home_page_url)

        if isinstance(prevalidate_result, dict) and not prevalidate_result.get("success", True):
            state["status"] = "fail"
            state["error"] = prevalidate_result.get("error", "Unknown error")
            return state
        else:
            try:
                prevalidate_result.quit()
            except Exception:
                pass
            state["error"] = None
    except Exception as e:
        state["status"] = "fail"
        state["error"] = f"Pre-validation error: {str(e)}"
        return state

    raw_output = run_tests_and_get_output(test_file_path)

    # if "Traceback" in raw_output and "login" in raw_output:
    #     print("❌ Test failed. Passing error to code generator.")
    #     state["error"] = raw_output  # this is where your raw_output goes
    #     state["status"] = "fail"
    #     state["retry_count"] = state.get("retry_count", 0) + 1
    #     return state

    report = generate_test_report_from_output(raw_output)
    report_path = "generated_code/test_report.md"
    save_test_report(report, report_path)

    report_generated = os.path.exists(report_path)
    return {
        "test_file_path": test_file_path,
        "test_code": parsed_code,
        "report_generated": report_generated,
        "status": "success" if report_generated else "fail",
        "error": None if report_generated else "Report not generated",
    }
